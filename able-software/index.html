<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Able-Software</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            body {
                font-family: 'Courier New', Courier, monospace;
                padding: 1rem;
            }
            bold, h1 {
                font-size: 4rem;
                text-align: center;
                width: 100%;
            }
            bold {
                padding-right: 2px;
            }
            footer {
                margin-top: 4rem;
                text-align: center;
                width: 100%;
            }
        </style>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
        
        <main>
            <header>
                <h1>Able-Software</h1>
                <p>These are some of the key values I believe software should have. It just so happens they all end in 'able', hence 'Able-Software'. And as a bonus backronym, they spell 'MR FEAST'.</p>
            </header>
            <article>
                <h2>
                    <bold>M</bold>aintainable
                </h2>
                <p>Software should be easy to maintain; to keep up-to-date, fix bugs, refactor and adjust. Remember, software should be soft, it is not hardware, the softer and more malleable the better.</p>
            </article>
            <article>
                <h2>
                    <bold>R</bold>eadable
                </h2>
                <p>
                    Software should be easy to read. Clean code, with well a laid out structure, appropriately named classes, functions and variables, and formatting will make for accessible code, that is easy to understand and reason about.
                </p>
            </article>
            <article>
                <h2>
                    <bold>F</bold>lexible
                </h2>
                <p>
                    Software should be flexible. Using design patterns such as Inversion of Control and Dependency Injection make for more loosely coupled components that can be independently exchanged or upgraded.
                </p>
            </article>
            <article>
                <h2>
                    <bold>E</bold>extensible
                </h2>
                <p>Software should be easy to build upon. Laying out code in a modular fashion, such as with the use of frameworks, makes it easy to extend functionality with minimal effort.</p>
            </article>
            <article>
                <h2>
                    <bold>A</bold>pplicable
                </h2>
                <p>Software should be relevant. Using design principles such as Domain Driven Design and Test Driven Design can help to make software more appropriate to its use case. Dead and 'non-functional' code should be pruned away. It's important to write software to suit its consumers, for example, software consumed primarily by humans should have an accessible UI and UX.</p>
            </article>
            <article>
                <h2>
                    <bold>S</bold>calable
                </h2>
                <p>Software should work well at scale. Modular design and writing code with bulk operations in mind can help make software that works well not only in development with a single but also in production with many concurrent users and high workload demand. Building software that is conducive to horizontal scaling can allow for the use of responsive infrastructure which can fit usage patterns in a cost-effective way.</p>
            </article>
            <article>
                <h2>
                    <bold>T</bold>estable
                </h2>
                <p>Software should be provable. Knowing that a piece of code works is good, but being able to prove it is better. Well written, high-quality tests provide a safety-net for future development, with optimal coverage you can be more sure that changes to one part of a codebase haven't affected the functionality of another. Test Driven Development is a sound means to writing testable code. Highly testable code is also conducive to Continuos Integration and Continuos Deployment, infrastructure and code dependencies can be automatically updated and tested prior to deployment without intervention saving valuable resources and improving security.</p>
            </article>
            <footer>
                GavG 2023
            </footer>
        </main>
    </body>
</html>