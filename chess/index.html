<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title>Chess</title>
  <style>
    html,
    body {
      margin: 0px;
      padding: 0px;
    }

    body {
      background: #353535;
      font: normal 9vh "Lucida Sans Unicode", "Lucida Grande", "Arial Unicode MS", sans-serif;
    }

    table {
      margin: 1vh auto;
      background: #DB8;
      border-collapse: collapse;
    }

    td {
      width: 12vh;
      height: 12vh;
      text-align: center;
      font-size: 9vh;
      padding: 0px;
    }

    table,
    td {
      transition: transform 1s ease-in-out;
    }

    td:after {
      top: 0;
      left: 0;
      display: flex;
      justify-content: center;
      background-color: transparent;
      position: relative;
      transform: rotate(0deg);
      transition: all 0.2s ease-in-out;
    }

    table.rotate {
      transform: rotate(180deg);
    }

    table.rotate td:after {
      transform: rotate(180deg) !important;
    }

    tr:nth-child(even) td:nth-child(odd) {
      background: #555;
    }

    tr:nth-child(odd) td:nth-child(even) {
      background: #555;
    }

    td.b {
      color: #000;
    }

    td.w {
      color: #f9f9f9;
    }

    td.c {
      background-color: #E22 !important;
    }

    td.h:after {
      content: '';
      display: table-cell;
      background-color: #33889955;
      width: 12vh;
      height: 12vh;
    }

    td.R:after {
      content: '\265C';
    }

    td.N:after {
      content: '\265E';
    }

    td.B:after {
      content: '\265D';
    }

    td.K:after {
      content: '\265A';
    }

    td.Q:after {
      content: '\265B';
    }

    td.P:after {
      content: '\265F';
    }

    td.a {
      background-color: #ff9900 !important;
    }

    td.y-1:after {
      top: -12vh;
    }

    td.y-2:after {
      top: -24vh;
    }

    td.y-3:after {
      top: -36vh;
    }

    td.y-4:after {
      top: -48vh;
    }

    td.y-5:after {
      top: -60vh;
    }

    td.y-6:after {
      top: -72vh;
    }

    td.y-7:after {
      top: -84vh;
    }

    td.y1:after {
      top: 12vh;
    }

    td.y2:after {
      top: 24vh;
    }

    td.y3:after {
      top: 36vh;
    }

    td.y4:after {
      top: 48vh;
    }

    td.y5:after {
      top: 60vh;
    }

    td.y6:after {
      top: 72vh;
    }

    td.y7:after {
      top: 84vh;
    }

    td.x-1:after {
      left: -12vh;
    }

    td.x-2:after {
      left: -24vh;
    }

    td.x-3:after {
      left: -36vh;
    }

    td.x-4:after {
      left: -48vh;
    }

    td.x-5:after {
      left: -60vh;
    }

    td.x-6:after {
      left: -72vh;
    }

    td.x-7:after {
      left: -84vh;
    }

    td.x1:after {
      left: 12vh;
    }

    td.x2:after {
      left: 24vh;
    }

    td.x3:after {
      left: 36vh;
    }

    td.x4:after {
      left: 48vh;
    }

    td.x5:after {
      left: 60vh;
    }

    td.x6:after {
      left: 72vh;
    }

    td.x7:after {
      left: 84vh;
    }
  </style>
</head>

<body>
  <table id='board'>
    <tr>
      <td id='1' class='b R'></td>
      <td id='2' class='b N'></td>
      <td id='3' class='b B'></td>
      <td id='4' class='b Q'></td>
      <td id='5' class='b K'></td>
      <td id='6' class='b B'></td>
      <td id='7' class='b N'></td>
      <td id='8' class='b R'></td>
    </tr>
    <tr>
      <td id='9' class='b P'></td>
      <td id='A' class='b P'></td>
      <td id='B' class='b P'></td>
      <td id='C' class='b P'></td>
      <td id='D' class='b P'></td>
      <td id='E' class='b P'></td>
      <td id='F' class='b P'></td>
      <td id='G' class='b P'></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td id='H' class='w P'></td>
      <td id='I' class='w P'></td>
      <td id='J' class='w P'></td>
      <td id='K' class='w Q'></td>
      <td id='L' class='w P'></td>
      <td id='M' class='w P'></td>
      <td id='N' class='w P'></td>
      <td id='O' class='w P'></td>
    </tr>
    <tr>
      <td id='P' class='w R'></td>
      <td id='Q' class='w N'></td>
      <td id='R' class='w B'></td>
      <td id='S' class='w Q'></td>
      <td id='T' class='w K'></td>
      <td id='U' class='w B'></td>
      <td id='V' class='w N'></td>
      <td id='W' class='w R'></td>
    </tr>
  </table>
</body>

<script type="text/javascript">
  const white = 'w';
  const black = 'b';
  const active_class = 'a';
  const check_class = 'c';
  const highlighted_class = 'h';
  const rook = 'R';
  const bishop = 'B';
  const knight = 'N';
  const pawn = 'P';
  const queen = 'Q';
  const king = 'K';
  const piece_list = [rook, bishop, knight, pawn, queen, king];

  var board = document.getElementById('board');
  var cells = board.getElementsByTagName('td');
  var active_cell = null;
  var turn = white;
  var highlighted_cells = [];
  var kings = board.getElementsByClassName('K');

  board.addEventListener('click', function(event) {
    cell = event.target;

    if (active_cell && isHighlightedCell(cell)) {
      var target_cell = active_cell;
      clearActiveCell();
      clearHighlightedCells();
      return movePiece(target_cell, cell)
    }

    if (isPlayablePiece(cell)) {
      setActiveCell(cell);
    } else {
      clearActiveCell();
      clearHighlightedCells();
    }
  })

  function rotateBoard() {
    board.classList.toggle('rotate');
  }

  function isPlayablePiece(cell) {
    return cell.classList.contains(turn);
  }

  function clearActiveCell() {
    if (active_cell) {
      active_cell.classList.remove(active_class);
      active_cell = null;
    }
  }

  function setActiveCell(cell) {
    clearActiveCell();
    if (active_cell != cell) {
      active_cell = cell;
      cell.classList.add(active_class);
      highlightCells(viableCells(cell));
    } else {
      active_cell = null;
    }
  }

  function highlightCells(cells = []) {
    clearHighlightedCells();
    highlighted_cells = cells;
    for (var i = 0; i < cells.length; i++) {
      cells[i].classList.add(highlighted_class);
    }
  }

  function clearHighlightedCells() {
    dehighlightCells(highlighted_cells);
  }

  function dehighlightCells(cells = []) {
    for (var i = 0; i < cells.length; i++) {
      cells[i].classList.remove(highlighted_class);
    }
  }

  function isHighlightedCell(cell) {
    if (cell) return cell.classList.contains(highlighted_class);
  }

  function checkAll() {
    var pieces = board.querySelectorAll('.' + white + ', ' + '.' + black)
    for (var i = 0; i < pieces.length; i++) {
      viableCells(pieces[i]);
    }
  }

  function removePieceClass(cell) {
    for (var i = 0; i < piece_list.length; i++) {
      cell.classList.remove(piece_list[i]);
    }
  }

  function movePiece(current_cell, new_cell) {

    clearCheckerCells();

    var base_class_list = [].slice.call(current_cell.classList);
    var x = new_cell.cellIndex - current_cell.cellIndex
    var y = new_cell.parentNode.rowIndex - current_cell.parentNode.rowIndex;

    if (x) current_cell.classList.add('x' + x);
    if (y) current_cell.classList.add('y' + y);

    setTimeout(function() {
      removePieceClass(new_cell);
      new_cell.classList.add(...base_class_list);
      new_cell.id = current_cell.id
      current_cell.id = null;
      current_cell.classList = [];

      checkAll();
      checkKings();
      rotateBoard();
      turn = (turn == white) ? black : white;
    }, 200)
  }

  function isWhite(cell) {
    return cell.classList.contains(white);
  }

  function isBlack(cell) {
    return cell.classList.contains(black);
  }

  function enemyClass(cell) {
    if (isWhite(cell)) return black;
    return white;
  }

  function getPieceType(cell) {
    for (var i = 0; i < piece_list.length; i++) {
      if (cell.classList.contains(piece_list[i])) return piece_list[i];
    }
  }

  function getPieceColor(cell) {
    if (isWhite(cell)) return white;
    return black;
  }

  function checkerClass(cell) {
    return check_class + getPieceColor(cell) + cell.id + getPieceType(cell);
  }

  function clearCheckerCells() {
    for (var i = 0; i < board.rows.length; i++) {
      for (var j = 0; j < board.rows[i].cells.length; j++) {
        var classes = [].slice.call(board.rows[i].cells[j].classList)
        for (var c = 0; c < classes.length; c++) {
          if (classes[c].substring(0, 2) == 'cb' || classes[c].substring(0, 2) == 'cw') {
            board.rows[i].cells[j].classList.remove(classes[c]);
          }
        }
      }
    }
  }

  function checkKings() {
    for (var i = 0; i < kings.length; i++) {
      if (inCheck(kings[i])) {
        kings[i].classList.add(check_class);
      } else {
        kings[i].classList.remove(check_class);
      }
    }
  }

  function inCheck(cell) {
    var enemyCheck = check_class + enemyClass(cell);
    for (var i = 0; i < cell.classList.length; i++) {
      if (cell.classList[i].substring(0, 2) === enemyCheck) return true;
    }
  }

  function markThreatened(checker, target) {
    target.classList.add(checkerClass(checker));
  }

  function isOccupied(cell) {
    return isBlack(cell) || isWhite(cell);
  }

  function isCapturable(cell) {
    if (turn === white) return isBlack(cell);
    return isWhite(cell);
  }

  function turnDirection() {
    return turn == white ? -1 : 1;
  }

  function viableCells(cell) {

    if (cell.classList.contains(pawn)) {
      if ((isBlack(cell) && cell.parentNode.rowIndex == 1) || (isWhite(cell) && cell.parentNode.rowIndex == 6)) {
        var viable_cells = n_y(1, cell, 2, false);
      } else {
        var viable_cells = n_y(1, cell, 1, false);
      }
      var diagonals = n_yx(1, 1, cell, 1).concat(n_yx(-1, 1, cell, 1));
      for (var i = 0; i < diagonals.length; i++) {
        if (isCapturable(diagonals[i])) viable_cells.push(diagonals[i]);
      }
      return viable_cells;
    }

    if (cell.classList.contains(rook)) {
      return [].concat(
        n_y(1, cell),
        n_y(-1, cell),
        n_x(1, cell),
        n_x(-1, cell)
      );
    }

    if (cell.classList.contains(queen)) {
      return [].concat(
        n_y(1, cell),
        n_y(-1, cell),
        n_x(1, cell),
        n_x(-1, cell),
        n_yx(1, -1, cell),
        n_yx(-1, 1, cell),
        n_yx(1, 1, cell),
        n_yx(-1, -1, cell),
      );
    }

    if (cell.classList.contains(king)) {
      return [].concat(
        n_y(1, cell, 1),
        n_y(-1, cell, 1),
        n_x(1, cell, 1),
        n_x(-1, cell, 1),
        n_yx(1, -1, cell, 1),
        n_yx(-1, 1, cell, 1),
        n_yx(1, 1, cell, 1),
        n_yx(-1, -1, cell, 1),
      );
    }

    if (cell.classList.contains(bishop)) {
      return [].concat(
        n_yx(1, -1, cell),
        n_yx(-1, 1, cell),
        n_yx(1, 1, cell),
        n_yx(-1, -1, cell),
      );
    }

    if (cell.classList.contains(knight)) {
      return [].concat(
        n_x2y(1, cell),
        n_x2y(-1, cell),
        n_y2x(1, cell),
        n_y2x(-1, cell),
      );
    }
  }

  function n_y(heading = 1, cell, n = 7, can_capture = true, blocking = true) {
    var y = cell.parentNode.rowIndex;
    var viable_cells = [];

    for (var i = 1; i < n + 1; i++) {
      var row = board.rows[y + (turnDirection() * heading * i)];
      if (row) {
        var target_cell = row.cells[cell.cellIndex];
        var capturable = isCapturable(target_cell);
        if (!blocking || (!isOccupied(target_cell) || (can_capture && capturable))) {
          viable_cells.push(target_cell);
          if (can_capture) markThreatened(cell, target_cell);
          if (capturable) break;
        } else {
          break;
        }
      }
    }
    return viable_cells;
  }

  function n_x(heading = 1, cell, n = 7, can_capture = true, blocking = true) {
    var x = cell.cellIndex;
    var row = cell.parentNode;
    var viable_cells = [];

    for (var i = 1; i < n + 1; i++) {
      var target_cell = row.cells[x + (i * heading)];
      if (typeof target_cell !== 'undefined') {
        var capturable = isCapturable(target_cell);
        if (!blocking || (!isOccupied(target_cell) || (can_capture && capturable))) {
          viable_cells.push(target_cell);
          if (can_capture) markThreatened(cell, target_cell);
          if (capturable) break;
        } else {
          break;
        }
      }
    }
    return viable_cells;
  }

  function n_yx(heading_x, heading_y, cell, n = 7, can_capture = true) {
    var y = cell.parentNode.rowIndex;
    var x = cell.cellIndex;
    var viable_cells = [];

    heading_y = turnDirection() * heading_y;

    for (var i = 1; i < n + 1; i++) {
      var row = board.rows[y + (heading_y * i)];
      if (row) {
        var target_cell = row.cells[x + (heading_x * i)];
        if (typeof(target_cell) !== 'undefined') {
          var capturable = isCapturable(target_cell);
          if (!isOccupied(target_cell) || (can_capture && capturable)) {
            viable_cells.push(target_cell);
            if (can_capture) markThreatened(cell, target_cell);
            if (capturable) break;
          } else {
            break;
          }
        } else {
          return viable_cells;
        }
      }
    }
    return viable_cells;
  }

  function n_x2y(heading, cell) {
    var y = cell.parentNode.rowIndex;
    var x = cell.cellIndex;
    var viable_cells = [];

    var row = board.rows[y + heading];

    if (typeof row !== 'undefined') {
      var target_cell_l = row.cells[x + 2];
      var target_cell_r = row.cells[x - 2];

      if ((typeof target_cell_l !== 'undefined') && (isCapturable(target_cell_l) || !isOccupied(target_cell_l))) {
        viable_cells.push(target_cell_l)
        markThreatened(cell, target_cell_l);
      };
      if ((typeof target_cell_r !== 'undefined') && (isCapturable(target_cell_r) || !isOccupied(target_cell_r))) {
        viable_cells.push(target_cell_r);
        markThreatened(cell, target_cell_r);
      };
    }
    return viable_cells;
  }

  function n_y2x(heading, cell) {
    var y = cell.parentNode.rowIndex;
    var x = cell.cellIndex;
    var viable_cells = [];

    var row = board.rows[y + (heading * 2)];

    if (typeof row !== 'undefined') {
      var target_cell_l = row.cells[x + 1];
      var target_cell_r = row.cells[x - 1];

      if ((typeof target_cell_l !== 'undefined') && (isCapturable(target_cell_l) || !isOccupied(target_cell_l))) {
        viable_cells.push(target_cell_l);
        markThreatened(cell, target_cell_l);
      };
      if ((typeof target_cell_r !== 'undefined') && (isCapturable(target_cell_r) || !isOccupied(target_cell_r))) {
        viable_cells.push(target_cell_r);
        markThreatened(cell, target_cell_r);
      };
    }
    return viable_cells;
  }
</script>

</html>